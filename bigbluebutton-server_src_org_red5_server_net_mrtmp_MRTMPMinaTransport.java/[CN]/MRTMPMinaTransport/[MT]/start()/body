{
  initIOHandler();
  ByteBuffer.setUseDirectBuffers(!useHeapBuffers);
  if (useHeapBuffers)   ByteBuffer.setAllocator(new SimpleByteBufferAllocator());
  log.info("MRTMP Mina Transport Settings");
  log.info("IO Threads: " + ioThreads);
  log.info("Event Threads:" + " core: " + eventThreadsCore + "+1"+ " max: "+ eventThreadsMax+ "+1"+ " queue: "+ eventThreadsQueue+ " keepalive: "+ eventThreadsKeepalive);
  eventExecutor=new ThreadPoolExecutor(eventThreadsCore + 1,eventThreadsMax + 1,eventThreadsKeepalive,TimeUnit.SECONDS,threadQueue(eventThreadsQueue));
  ((ThreadPoolExecutor)eventExecutor).setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
  acceptor=new SocketAcceptor(ioThreads,Executors.newCachedThreadPool());
  acceptor.getFilterChain().addLast("threadPool",new ExecutorFilter(eventExecutor));
  SocketAcceptorConfig config=acceptor.getDefaultConfig();
  config.setThreadModel(ThreadModel.MANUAL);
  config.setReuseAddress(false);
  config.setBacklog(100);
  log.info("TCP No Delay: " + tcpNoDelay);
  log.info("Receive Buffer Size: " + receiveBufferSize);
  log.info("Send Buffer Size: " + sendBufferSize);
  SocketSessionConfig sessionConf=(SocketSessionConfig)config.getSessionConfig();
  sessionConf.setReuseAddress(true);
  sessionConf.setTcpNoDelay(tcpNoDelay);
  if (isLoggingTraffic) {
    log.info("Configuring traffic logging filter");
    IoFilter filter=new LoggingFilter();
    acceptor.getFilterChain().addFirst("LoggingFilter",filter);
  }
  SocketAddress socketAddress=null;
  while (true) {
    try {
      socketAddress=(address == null) ? new InetSocketAddress(port) : new InetSocketAddress(address,port);
      acceptor.bind(socketAddress,ioHandler);
      break;
    }
 catch (    Exception e) {
      port++;
    }
  }
  log.info("MRTMP Mina Transport bound to " + socketAddress.toString());
}
