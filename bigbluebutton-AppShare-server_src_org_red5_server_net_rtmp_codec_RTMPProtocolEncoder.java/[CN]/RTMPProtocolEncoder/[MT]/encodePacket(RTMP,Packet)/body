{
  final Header header=packet.getHeader();
  final int channelId=header.getChannelId();
  final IRTMPEvent message=packet.getMessage();
  ByteBuffer data;
  if (message instanceof ChunkSize) {
    ChunkSize chunkSizeMsg=(ChunkSize)message;
    rtmp.setWriteChunkSize(chunkSizeMsg.getSize());
  }
  try {
    data=encodeMessage(rtmp,header,message);
  }
  finally {
    message.release();
  }
  if (data.position() != 0) {
    data.flip();
  }
 else {
    data.rewind();
  }
  header.setSize(data.limit());
  final Header lastHeader=rtmp.getLastWriteHeader(channelId);
  final int headerSize=calculateHeaderSize(header,lastHeader);
  rtmp.setLastWriteHeader(channelId,header);
  rtmp.setLastWritePacket(channelId,packet);
  final int chunkSize=rtmp.getWriteChunkSize();
  int chunkHeaderSize=1;
  if (header.getChannelId() > 320)   chunkHeaderSize=3;
 else   if (header.getChannelId() > 63)   chunkHeaderSize=2;
  final int numChunks=(int)Math.ceil(header.getSize() / (float)chunkSize);
  final int bufSize=header.getSize() + headerSize + (numChunks > 0 ? (numChunks - 1) * chunkHeaderSize : 0);
  final ByteBuffer out=ByteBuffer.allocate(bufSize,false);
  encodeHeader(header,lastHeader,out);
  if (numChunks == 1) {
    BufferUtils.put(out,data,out.remaining());
  }
 else {
    for (int i=0; i < numChunks - 1; i++) {
      BufferUtils.put(out,data,chunkSize);
      RTMPUtils.encodeHeaderByte(out,HEADER_CONTINUE,header.getChannelId());
    }
    BufferUtils.put(out,data,out.remaining());
  }
  data.release();
  out.flip();
  data=null;
  return out;
}
