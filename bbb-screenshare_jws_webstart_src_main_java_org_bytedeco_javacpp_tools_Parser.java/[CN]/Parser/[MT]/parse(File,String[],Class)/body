{
  ClassProperties allProperties=Loader.loadProperties(cls,properties,true);
  ClassProperties clsProperties=Loader.loadProperties(cls,properties,false);
  List<String> cIncludes=new ArrayList<>();
  cIncludes.addAll(clsProperties.get("platform.cinclude"));
  cIncludes.addAll(allProperties.get("platform.cinclude"));
  List<String> clsIncludes=new ArrayList<String>();
  clsIncludes.addAll(clsProperties.get("platform.include"));
  clsIncludes.addAll(clsProperties.get("platform.cinclude"));
  List<String> allIncludes=new ArrayList<String>();
  allIncludes.addAll(allProperties.get("platform.include"));
  allIncludes.addAll(allProperties.get("platform.cinclude"));
  List<String> allTargets=allProperties.get("target");
  List<String> clsTargets=clsProperties.get("target");
  List<String> clsHelpers=clsProperties.get("helper");
  String target=clsTargets.get(0);
  List<Class> allInherited=allProperties.getInheritedClasses();
  infoMap=new InfoMap();
  for (  Class c : allInherited) {
    try {
      ((InfoMapper)c.newInstance()).map(infoMap);
    }
 catch (    ClassCastException|InstantiationException|IllegalAccessException e) {
    }
  }
  leafInfoMap=new InfoMap();
  try {
    ((InfoMapper)cls.newInstance()).map(leafInfoMap);
  }
 catch (  ClassCastException|InstantiationException|IllegalAccessException e) {
  }
  infoMap.putAll(leafInfoMap);
  String version=Generator.class.getPackage().getImplementationVersion();
  if (version == null) {
    version="unknown";
  }
  String text="// Targeted by JavaCPP version " + version + ": DO NOT EDIT THIS FILE\n\n";
  int n=target.lastIndexOf('.');
  if (n >= 0) {
    text+="package " + target.substring(0,n) + ";\n\n";
  }
  List<Info> infoList=leafInfoMap.get(null);
  for (  Info info : infoList) {
    if (info.javaText != null && info.javaText.startsWith("import")) {
      text+=info.javaText + "\n";
    }
  }
  text+="import java.nio.*;\n" + "import org.bytedeco.javacpp.*;\n" + "import org.bytedeco.javacpp.annotation.*;\n\n";
  for (  String s : allTargets) {
    if (!target.equals(s)) {
      text+="import static " + s + ".*;\n";
    }
  }
  if (allTargets.size() > 1) {
    text+="\n";
  }
  text+="public class " + target.substring(n + 1) + " extends "+ (clsHelpers.size() > 0 && clsIncludes.size() > 0 ? clsHelpers.get(0) : cls.getCanonicalName())+ " {\n"+ "    static { Loader.load(); }\n";
  String targetPath=target.replace('.',File.separatorChar);
  File targetFile=new File(outputDirectory,targetPath + ".java");
  logger.info("Targeting " + targetFile);
  Context context=new Context();
  context.infoMap=infoMap;
  String[] includePath=classPath;
  n=targetPath.lastIndexOf(File.separatorChar);
  if (n >= 0) {
    includePath=classPath.clone();
    for (int i=0; i < includePath.length; i++) {
      includePath[i]+=File.separator + targetPath.substring(0,n);
    }
  }
  List<String> paths=allProperties.get("platform.includepath");
  String[] includePaths=paths.toArray(new String[paths.size() + includePath.length]);
  System.arraycopy(includePath,0,includePaths,paths.size(),includePath.length);
  DeclarationList declList=new DeclarationList();
  for (  String include : allIncludes) {
    if (!clsIncludes.contains(include)) {
      boolean isCFile=cIncludes.contains(include);
      parse(context,declList,includePaths,include,isCFile);
    }
  }
  declList=new DeclarationList(declList);
  if (clsIncludes.size() > 0) {
    containers(context,declList);
    for (    String include : clsIncludes) {
      if (allIncludes.contains(include)) {
        boolean isCFile=cIncludes.contains(include);
        parse(context,declList,includePaths,include,isCFile);
      }
    }
  }
  final String newline=lineSeparator != null ? lineSeparator : "\n";
  try (Writer out=new FileWriter(targetFile){
    @Override public Writer append(    CharSequence text) throws IOException {
      return super.append(((String)text).replace("\n",newline).replace("\\u","\\u005Cu"));
    }
  }
){
    out.append(text);
    for (    Info info : infoList) {
      if (info.javaText != null && !info.javaText.startsWith("import")) {
        out.append(info.javaText + "\n");
      }
    }
    for (    Declaration d : declList) {
      out.append(d.text);
    }
    out.append("\n}\n").close();
  }
   return targetFile;
}
