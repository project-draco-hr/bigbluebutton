{
  int type=readAMF3Integer();
  if ((type & 1) == 0) {
    return getReference(type >> 1);
  }
  type>>=1;
  List<String> attributes=null;
  String className;
  Object result=null;
  boolean inlineClass=(type & 1) == 1;
  if (!inlineClass) {
    ClassReference info=classReferences.get(type >> 1);
    className=info.className;
    attributes=info.attributeNames;
    type=info.type;
    if (attributes != null) {
      type|=attributes.size() << 2;
    }
  }
 else {
    type>>=1;
    className=readString();
  }
  amf3_mode+=1;
  Object instance=newInstance(className);
  Map<String,Object> properties=null;
  PendingObject pending=new PendingObject();
  int tempRefId=storeReference(pending);
switch (type & 0x03) {
case AMF3.TYPE_OBJECT_PROPERTY:
    int count=type >> 2;
  properties=new ObjectMap<String,Object>();
if (attributes == null) {
  attributes=new ArrayList<String>(count);
  for (int i=0; i < count; i++) {
    attributes.add(readString());
  }
  classReferences.add(new ClassReference(className,AMF3.TYPE_OBJECT_PROPERTY,attributes));
}
for (int i=0; i < count; i++) {
String name=attributes.get(i);
properties.put(name,deserializer.deserialize(this,getPropertyType(instance,name)));
}
break;
case AMF3.TYPE_OBJECT_EXTERNALIZABLE:
if ("".equals(className)) throw new RuntimeException("need a classname to load an externalizable object");
result=newInstance(className);
if (result == null) throw new RuntimeException("could not instantiate class");
if (!(result instanceof IExternalizable)) throw new RuntimeException("the class must implement the IExternalizable interface");
classReferences.add(new ClassReference(className,AMF3.TYPE_OBJECT_EXTERNALIZABLE,null));
storeReference(tempRefId,result);
((IExternalizable)result).readExternal(new DataInput(this,deserializer));
break;
case AMF3.TYPE_OBJECT_VALUE:
classReferences.add(new ClassReference(className,AMF3.TYPE_OBJECT_VALUE,null));
properties=new ObjectMap<String,Object>();
attributes=new LinkedList<String>();
String key=readString();
while (!"".equals(key)) {
attributes.add(key);
Object value=deserializer.deserialize(this,getPropertyType(instance,key));
properties.put(key,value);
key=readString();
}
break;
default :
case AMF3.TYPE_OBJECT_PROXY:
if ("".equals(className)) throw new RuntimeException("need a classname to load an externalizable object");
result=newInstance(className);
if (result == null) throw new RuntimeException("could not instantiate class");
if (!(result instanceof IExternalizable)) throw new RuntimeException("the class must implement the IExternalizable interface");
classReferences.add(new ClassReference(className,AMF3.TYPE_OBJECT_PROXY,null));
storeReference(tempRefId,result);
((IExternalizable)result).readExternal(new DataInput(this,deserializer));
}
amf3_mode-=1;
if (result == null) {
if ("".equals(className)) {
for (Map.Entry<String,Object> entry : properties.entrySet()) {
if (entry.getValue() == pending) {
entry.setValue(properties);
}
}
storeReference(tempRefId,properties);
result=properties;
}
 else if ("RecordSet".equals(className)) {
throw new RuntimeException("Objects of type RecordSet not supported yet.");
}
 else if ("RecordSetPage".equals(className)) {
throw new RuntimeException("Objects of type RecordSetPage not supported yet.");
}
 else {
result=newInstance(className);
if (result != null) {
storeReference(tempRefId,result);
Class resultClass=result.getClass();
pending.resolveProperties(result);
for (Map.Entry<String,Object> entry : properties.entrySet()) {
final String key=entry.getKey();
Object value=entry.getValue();
if (value == pending) {
value=result;
}
if (value instanceof PendingObject) {
((PendingObject)value).addPendingProperty(result,resultClass,key);
continue;
}
try {
try {
final Field field=resultClass.getField(key);
final Class fieldType=field.getType();
if (!fieldType.isAssignableFrom(value.getClass())) {
value=ConversionUtils.convert(value,fieldType);
}
field.set(result,value);
}
 catch (Exception e) {
BeanUtils.setProperty(result,key,value);
}
}
 catch (Exception e) {
log.error("Error mapping property: {} ({})",key,value);
}
}
}
}
}
return result;
}
