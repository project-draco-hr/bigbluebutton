{
  byte headerByte=in.get();
  int headerValue;
  int byteCount=1;
  if ((headerByte & 0x3f) == 0) {
    headerValue=((int)headerByte & 0xff) << 8 | ((int)in.get() & 0xff);
    byteCount=2;
  }
 else   if ((headerByte & 0x3f) == 1) {
    headerValue=((int)headerByte & 0xff) << 16 | ((int)in.get() & 0xff) << 8 | ((int)in.get() & 0xff);
    byteCount=3;
  }
 else {
    headerValue=(int)headerByte & 0xff;
    byteCount=1;
  }
  final int channelId=RTMPUtils.decodeChannelId(headerValue,byteCount);
  final int headerSize=RTMPUtils.decodeHeaderSize(headerValue,byteCount);
  Header header=new Header();
  header.setChannelId(channelId);
  header.setTimerRelative(headerSize != HEADER_NEW);
switch (headerSize) {
case HEADER_NEW:
    header.setTimer(RTMPUtils.readUnsignedMediumInt(in));
  header.setSize(RTMPUtils.readMediumInt(in));
header.setDataType(in.get());
header.setStreamId(RTMPUtils.readReverseInt(in));
break;
case HEADER_SAME_SOURCE:
header.setTimer(RTMPUtils.readUnsignedMediumInt(in));
header.setSize(RTMPUtils.readMediumInt(in));
header.setDataType(in.get());
header.setStreamId(lastHeader.getStreamId());
break;
case HEADER_TIMER_CHANGE:
header.setTimer(RTMPUtils.readUnsignedMediumInt(in));
header.setSize(lastHeader.getSize());
header.setDataType(lastHeader.getDataType());
header.setStreamId(lastHeader.getStreamId());
break;
case HEADER_CONTINUE:
header.setTimer(lastHeader.getTimer());
header.setSize(lastHeader.getSize());
header.setDataType(lastHeader.getDataType());
header.setStreamId(lastHeader.getStreamId());
break;
default :
log.error("Unexpected header size: " + headerSize);
return null;
}
return header;
}
