{
  byte event=in.get();
switch (event) {
case CAPTURE_START_EVENT:
    System.out.println("Decoding CAPTURE_START_EVENT");
  decodeCaptureStartEvent(session,in,out);
break;
case CAPTURE_UPDATE_EVENT:
decodeCaptureUpdateEvent(session,in,out);
break;
case CAPTURE_END_EVENT:
log.warn("Got CAPTURE_END_EVENT event: " + event);
System.out.println("Got CAPTURE_END_EVENT event: " + event);
decodeCaptureEndEvent(session,in,out);
break;
case MOUSE_LOCATION_EVENT:
decodeMouseLocationEvent(session,in,out);
break;
default :
log.error("Unknown event: " + event);
throwAwayCorruptedPacket(in);
Integer numErrors=(Integer)session.getAttribute("NUM_ERRORS",0);
session.setAttribute("NUM_ERRORS",numErrors++);
if (numErrors > 50) {
log.info("Closing session. Too many corrupt packets.");
int seqNum=0;
String room=(String)session.getAttribute(ROOM,null);
if (room != null) {
log.info("Closing session [" + room + "]. Too many corrupt packets.");
CaptureEndBlockEvent ceb=new CaptureEndBlockEvent(room,seqNum);
out.write(ceb);
}
 else {
log.info("Cannot determine session. Too many corrupt packets.");
}
CloseFuture future=session.close(true);
}
break;
}
}
