{
  log.debug("startTranscodingStream({},{})",broadcastStream.getPublishedName(),scope.getName());
  mInputListener=new IStreamListener(){
    public void packetReceived(    IBroadcastStream broadcastStream,    IStreamPacket packet){
      IoBuffer buf=packet.getData();
      if (buf != null)       buf.rewind();
      if (buf == null || buf.remaining() == 0) {
        log.debug("skipping empty packet with no data");
        return;
      }
      if (packet instanceof AudioData) {
        long now=System.currentTimeMillis();
        byte[] data=SerializeUtils.ByteBufferToByteArray(buf);
        if (packet.getTimestamp() - lastTS > 40) {
          System.out.println("   TS delay: [lastTS=" + lastTS + "[ts="+ packet.getTimestamp()+ "][pit="+ (now - lastPacketTimeRx)+ ", port="+ connInfo.getSocket().getLocalPort()+ "]");
        }
        String codec="UNKNOWN";
        int codecType=(int)(data[0] & 0xFF);
        if (codecType == 178) {
          codec="SPEEX";
        }
 else         if (codecType == 82) {
          codec="ULAW";
        }
        System.out.println("***PIT delay: [lastTS=" + lastTS + "[ts="+ packet.getTimestamp()+ "][pit="+ (now - lastPacketTimeRx)+ ", port="+ connInfo.getSocket().getLocalPort()+ "][codec="+ codec+ ","+ codecType+ "]");
        AudioByteData abd=new AudioByteData(data);
        try {
          audioDataQ.put(abd);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
        lastPacketTimeRx=now;
        lastTS=packet.getTimestamp();
      }
    }
  }
;
  lastPacketTimeRx=System.currentTimeMillis();
  broadcastStream.addStreamListener(mInputListener);
  rtpSender=new RtpStreamSender(srcSocket,connInfo);
  rtpSender.connect();
  processAudioData=true;
  audioDataProcessor=new Runnable(){
    public void run(){
      processAudioData();
    }
  }
;
  exec.execute(audioDataProcessor);
}
