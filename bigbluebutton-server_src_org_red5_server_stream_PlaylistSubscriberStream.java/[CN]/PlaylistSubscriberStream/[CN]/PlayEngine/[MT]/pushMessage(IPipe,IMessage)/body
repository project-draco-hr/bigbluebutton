{
  if (message instanceof ResetMessage) {
    sendReset();
    return;
  }
  if (message instanceof RTMPMessage) {
    RTMPMessage rtmpMessage=(RTMPMessage)message;
    IRTMPEvent body=rtmpMessage.getBody();
    if (!(body instanceof IStreamData)) {
      throw new RuntimeException("expected IStreamData but got " + body.getClass() + " (type "+ body.getDataType()+ ")");
    }
    int size=((IStreamData)body).getData().limit();
    if (body instanceof VideoData) {
      IVideoStreamCodec videoCodec=null;
      if (msgIn instanceof IBroadcastScope) {
        IClientBroadcastStream stream=(IClientBroadcastStream)((IBroadcastScope)msgIn).getAttribute(IBroadcastScope.STREAM_ATTRIBUTE);
        if (stream != null && stream.getCodecInfo() != null) {
          videoCodec=stream.getCodecInfo().getVideoCodec();
        }
      }
      if (videoCodec == null || videoCodec.canDropFrames()) {
        if (state == State.PAUSED) {
          videoFrameDropper.dropPacket(rtmpMessage);
          return;
        }
        long pendingVideos=pendingVideoMessages();
        if (!videoFrameDropper.canSendPacket(rtmpMessage,pendingVideos)) {
          return;
        }
        boolean drop=!videoBucket.acquireToken(size,0);
        if (!receiveVideo || drop) {
          videoFrameDropper.dropPacket(rtmpMessage);
          return;
        }
        Long[] writeDelta=getWriteDelta();
        if (pendingVideos > 1) {
          long now=System.currentTimeMillis();
          if (bufferCheckInterval > 0 && now >= nextCheckBufferUnderrun) {
            sendInsufficientBandwidthStatus(currentItem);
            nextCheckBufferUnderrun=now + bufferCheckInterval;
          }
          videoFrameDropper.dropPacket(rtmpMessage);
          return;
        }
        videoFrameDropper.sendPacket(rtmpMessage);
      }
    }
 else     if (body instanceof AudioData) {
      if (!receiveAudio && sendBlankAudio) {
        sendBlankAudio=false;
        body=new AudioData();
        if (lastMessage != null) {
          body.setTimestamp(lastMessage.getTimestamp());
        }
 else {
          body.setTimestamp(0);
        }
        rtmpMessage.setBody(body);
      }
 else       if (state == State.PAUSED || !receiveAudio || !audioBucket.acquireToken(size,0)) {
        return;
      }
    }
    if (body instanceof IStreamData && ((IStreamData)body).getData() != null) {
      bytesSent+=((IStreamData)body).getData().limit();
    }
    lastMessage=body;
  }
  msgOut.pushMessage(message);
}
