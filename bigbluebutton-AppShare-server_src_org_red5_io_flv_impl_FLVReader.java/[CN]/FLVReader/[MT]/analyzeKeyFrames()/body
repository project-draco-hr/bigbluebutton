{
  if (keyframeMeta != null) {
    return keyframeMeta;
  }
  if (keyframeCache != null) {
    keyframeMeta=keyframeCache.loadKeyFrameMeta(file);
    if (keyframeMeta != null) {
      duration=keyframeMeta.duration;
      posTimeMap=new HashMap<Long,Long>();
      for (int i=0; i < keyframeMeta.positions.length; i++) {
        posTimeMap.put(keyframeMeta.positions[i],(long)keyframeMeta.timestamps[i]);
      }
      posTagMap=new HashMap<Long,Integer>();
      posTagMap.put((long)0,0);
      return keyframeMeta;
    }
  }
  List<Long> positionList=new ArrayList<Long>();
  List<Integer> timestampList=new ArrayList<Integer>();
  List<Long> audioPositionList=new ArrayList<Long>();
  List<Integer> audioTimestampList=new ArrayList<Integer>();
  long origPos=getCurrentPosition();
  setCurrentPosition(9);
  posTagMap=new HashMap<Long,Integer>();
  int idx=0;
  boolean audioOnly=true;
  while (this.hasMoreTags()) {
    long pos=getCurrentPosition();
    posTagMap.put(pos,idx++);
    ITag tmpTag=this.readTagHeader();
    duration=tmpTag.getTimestamp();
    if (tmpTag.getDataType() == IoConstants.TYPE_VIDEO) {
      if (audioOnly) {
        audioOnly=false;
        audioPositionList.clear();
        audioTimestampList.clear();
      }
      if (firstVideoTag == -1) {
        firstVideoTag=pos;
      }
      fillBuffer(1);
      byte frametype=in.get();
      if (((frametype & MASK_VIDEO_FRAMETYPE) >> 4) == FLAG_FRAMETYPE_KEYFRAME) {
        positionList.add(pos);
        timestampList.add(tmpTag.getTimestamp());
      }
    }
 else     if (tmpTag.getDataType() == IoConstants.TYPE_AUDIO) {
      if (firstAudioTag == -1) {
        firstAudioTag=pos;
      }
      if (audioOnly) {
        audioPositionList.add(pos);
        audioTimestampList.add(tmpTag.getTimestamp());
      }
    }
    long newPosition=pos + tmpTag.getBodySize() + 15;
    if (newPosition >= getTotalBytes()) {
      log.info("New position exceeds limit");
      if (log.isDebugEnabled()) {
        log.debug("-----");
        log.debug("Keyframe analysis");
        log.debug(" data type=" + tmpTag.getDataType() + " bodysize="+ tmpTag.getBodySize());
        log.debug(" remaining=" + getRemainingBytes() + " limit="+ getTotalBytes()+ " new pos="+ newPosition);
        log.debug(" pos=" + pos);
        log.debug("-----");
      }
      break;
    }
 else {
      setCurrentPosition(newPosition);
    }
  }
  setCurrentPosition(origPos);
  keyframeMeta=new KeyFrameMeta();
  keyframeMeta.duration=duration;
  posTimeMap=new HashMap<Long,Long>();
  if (audioOnly) {
    positionList=audioPositionList;
    timestampList=audioTimestampList;
  }
  keyframeMeta.audioOnly=audioOnly;
  keyframeMeta.positions=new long[positionList.size()];
  keyframeMeta.timestamps=new int[timestampList.size()];
  for (int i=0; i < keyframeMeta.positions.length; i++) {
    keyframeMeta.positions[i]=positionList.get(i);
    keyframeMeta.timestamps[i]=timestampList.get(i);
    posTimeMap.put((long)positionList.get(i),(long)timestampList.get(i));
  }
  if (keyframeCache != null)   keyframeCache.saveKeyFrameMeta(file,keyframeMeta);
  return keyframeMeta;
}
