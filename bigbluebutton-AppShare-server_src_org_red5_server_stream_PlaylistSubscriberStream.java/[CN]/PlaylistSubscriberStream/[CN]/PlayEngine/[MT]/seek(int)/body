{
  if (state != State.PLAYING && state != State.PAUSED && state != State.STOPPED) {
    throw new IllegalStateException();
  }
  if (!isPullMode) {
    throw new OperationNotSupportedException();
  }
  releasePendingMessage();
  clearWaitJobs();
  bwController.resetBuckets(bwContext);
  isWaitingForToken=false;
  sendClearPing();
  sendReset();
  sendSeekStatus(currentItem,position);
  sendStartStatus(currentItem);
  int seekPos=sendVODSeekCM(msgIn,position);
  if (seekPos == -1) {
    seekPos=position;
  }
  playbackStart=System.currentTimeMillis() - seekPos;
  notifyItemSeek(currentItem,seekPos);
  boolean messageSent=false;
  boolean startPullPushThread=false;
  if ((state == State.PAUSED || state == State.STOPPED) && sendCheckVideoCM(msgIn)) {
    IMessage msg;
    try {
      msg=msgIn.pullMessage();
    }
 catch (    Throwable err) {
      log.error("Error while pulling message.",err);
      msg=null;
    }
    while (msg != null) {
      if (msg instanceof RTMPMessage) {
        RTMPMessage rtmpMessage=(RTMPMessage)msg;
        IRTMPEvent body=rtmpMessage.getBody();
        if (body instanceof VideoData && ((VideoData)body).getFrameType() == FrameType.KEYFRAME) {
          body.setTimestamp(seekPos);
          doPushMessage(rtmpMessage);
          rtmpMessage.getBody().release();
          messageSent=true;
          lastMessage=body;
          break;
        }
      }
      try {
        msg=msgIn.pullMessage();
      }
 catch (      Throwable err) {
        log.error("Error while pulling message.",err);
        msg=null;
      }
    }
  }
 else {
    startPullPushThread=true;
  }
  if (!messageSent) {
    AudioData audio=new AudioData();
    audio.setTimestamp(seekPos);
    audio.setHeader(new Header());
    audio.getHeader().setTimer(seekPos);
    audio.getHeader().setTimerRelative(false);
    RTMPMessage audioMessage=new RTMPMessage();
    audioMessage.setBody(audio);
    lastMessage=audio;
    doPushMessage(audioMessage);
  }
  if (startPullPushThread) {
    ensurePullAndPushRunning();
  }
  if (state != State.STOPPED && currentItem.getLength() >= 0 && (position - streamOffset) >= currentItem.getLength()) {
    stop();
    return;
  }
}
